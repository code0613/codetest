# 코딩테스트 No.27
## 설명 
- 1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될 때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다.
> 1-1. 입력된 수가 짝수라면 2로 나눕니다.<br>
    1-2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다.<br>
    2. 결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다.
- 주어진 수가 6이라면 6 → 3 → 10 → 5 → 16 → 8 → 4 → 2 → 1 이 되어 총 8번 만에 1이 됩니다. 
- 위 작업을 몇 번이나 반복해야 하는지 반환하는 함수, solution을 완성해 주세요. 단, 주어진 수가 1인 경우에는 0을, 작업을 500번 반복할 때까지 1이 되지 않는다면 –1을 반환해 주세요.

## 제한 조건
- 입력된 수, num은 1 이상 8,000,000 미만인 정수입니다.

``` java
class Solution {
    public int solution(long num) {
        int answer = 0;
        int count = 0;
        if (num ==1){
            answer =0;
            return answer;
        }
        boolean run = true;
        while (run){
            if (num % 2 == 0){
                num = num/2;
                count++;
                if (num == 1){
                    run = false;
                }
            } else if (num % 2 == 1) {
                num = (num*3)+1;
                count++;
                if (num == 1){
                    run = false;
                }
            }
        }
        if (count > 500){
            answer = -1;
        }else {
            answer = count;
        }
        return answer;
    }
}
```
## 문제점
문제 이름만 봐도 재밌을거같아서 기대하고 있던 문제이다

예외사항으로 1이 주어질 경우는 0을 반환한다

boolean변수 run을 정의하고 ture를 대입한다

while문을 돌면서 코드를 작성하고 if문을 통해 판별한다 판별하는 과정에서 1개의 작업이 끝나면 count++를 한다

count > 500이 된다면 즉 작업의 횟수가 500번을 넘는다면 answer = -1을 한다

그게 아니라면 answer = count를 하고 반환한다

# 후기
문제를 보고 로직을 고민하고 코드를 작성하는데는 평범했다

다만 문제를 잘 읽어보지않고 예외를 그대로 통과시켜서 이거 왜 안되는거지? 하긴했다

while문을 사용한 이유는 for문은 최초에 길이를 설정해줘야 하는데 내 기준으로는 뭔가 500을 적기에 코드가 안좋아 보였다

while문과 for문의 속도도 알아봤지만 이정도 수준의 코드에서는 거의 차이가 없거나 for문이 수 ms 앞선다

별 차이가 없는거같아 그대로 사용했다!